---
layout: post
title: 常见的垃圾回收算法有哪些？
lock: need
---


# 面试官：常见的垃圾回收算法有哪些？

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301000558193.jpg?)
## JVM运行数据区
Java在执行Java程序的过程中会把所管理的内存划分为为若干个不同的数据区域，如下图

JDK1.8之前方法区由永久代实现（永久代在堆中）
JDK1.8方法区由元空间实现（元空间在本地内存）

JDK1.8之前堆内存被分为新生代，老年代，永久代
JDK1.8之后堆内存被分为新生代，老年代，默认比例为1：2，新生代又被分为1个Eden区+2个Survivor区（S0区，S1区），其中Eden区，S0区，S1区的默认比例为8：1：1
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200229203744261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p6dGlfZXJsaWU=,size_16,color_FFFFFF,t_70)
**堆和方法区是所有线程共享的数据区**
**虚拟机栈，本地方法栈，程序计数器是线程隔离的数据区**
## 判断对象是否已死
1. 引用计数法（JVM没有采用这种，因为互相引用，会导致回收不了）
2. 可达性算法分析
### 标记-清除算法
![在这里插入图片描述](https://img-blog.csdnimg.cn/202002292307177.PNG?)

先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。也可以反过来，标记存活的对象，统一回收未被标记的对象

**缺点**

 1. 效率问题，标记和清除的两个过程的效率都不高
 2. 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
### 标记-复制算法
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200229230957804.PNG?)
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。

**优点**

这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

**缺点**

 将内存缩小为原来的一半

**改善**

将新生代分为一块较大的Eden空间和两块较小的Survivor空间（S0和S1）。每次分配内存时只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor上，接着清理掉Eden和已经用过的Survivor空间，循环往复。当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（大多就是老年代）进行分配担保

循环往复的过程如下
Eden+S0->S1（将Eden和S0存活的对象移动到S1）
Eden+S1->S0
Eden+S0->S1

### 标记-整理算法
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200229231012212.PNG?)
针对老年代对象的存亡特征，有人提出了标记-整理算法，标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。
## 总结
根据新生代的特点，绝大多数对象都是朝生夕灭的，所以**新生代一般用标记-复制算法**
根据老年代的特点，对象存活率较高，所以**老年代一般用标记-清除，标记-整理算法。关注吞吐量用标记-整理算法，关注延迟用标记-清除算法**